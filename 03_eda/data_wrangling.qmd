# Colllecte et préparation  des données

## connexion et vue d'ensemble de la base de données

```{r}
#| include: false
library(DBI)
library(odbc)
library(dplyr)
library(purrr)
library(lubridate)

```

```{r}



conn <- dbConnect(odbc(), .connection_string = "Driver={ODBC Driver 18 for SQL Server};", 
            Server = "server-sql-dunin-eve.database.windows.net", Database = "AviviaEve_Copy", 
            UID = "accesAviviaData", PWD = "Citric&Private&Designed&Maturity1&Cloning")


# selectionner les noms des tables 
print(DBI::dbListTables(conn,schema="dbo"))




```

les informations de la base de données sont principalement contenues dans trois tables principales : ProjetEW, CommEW et ContratEW.

```{r}
#| include: false

library(dplyr)

#acces aux tables  sans chargement en memoire
GetLazyDBAccess <- function(conn,tables){
  lazyDb <- lapply(tables, function(tbl_name) {
    tbl(conn, tbl_name) # Accesses each table from the connection
  })
  lazyDb
}

mainTables <- c("CommEW","ContratEW","ProjetEW")
AviviaDBData <- GetLazyDBAccess(conn,mainTables)
names(AviviaDBData) <- mainTables



print(AviviaDBData |> names())
```

## Sources et méthodes de collecte des données

```{r}
#| echo: false
 
# Création d'un tableau récapitulatif des sources de données
sources_data <- data.frame(
  Source = c("avivia database"),
  Type = c("Base de données SQL" ),
  Description = c("Base de donnée transactionnel des activités de ventes"),
  Methode_de_collecte = c(" Via la plateforme Eve "),
  Volumétrie = c("8 Go" ),
  Fréquence = c("Temps réel")
)

knitr::kable(sources_data, caption = "Vue d'ensemble des sources de données")
```

### table commandes

```{r}
AviviaDBData$CommEW |> head()
```

### table contrat

```{r}
AviviaDBData$ContratEW |> head()
```

### table projet

```{r}
AviviaDBData$ProjetEW |> head()
```

### structure de fichier xml

Après une analyse des champs des différentes tables, nous avons choisi de nous concentrer sur ceux contenant des fichiers XML notemment : ***`DocumXML`*****, *`EveXML`*** et *`ProjetXML`* . Ces derniers non seulement synthétisent les informations de chaque table, mais renferment également davantage de données pertinentes et intéressantes.

Exemple de la structure des fichiers xmls ( ils ont ensemble fondemmentalement la meme structure )

```{r}
library(xml2) 

AviviaDBData$CommEW |> head(1) |> pull(DocumXML) |> as_xml_document() |> xml_structure()
```

### extractions des information et tables potentielles des différents

fichiers xmls

### fichiers DocumXML et EveXML de la table CommEW (commandes)

```{r}
 load("C:/Users/datch/Desktop/aviviaMandatDoc/data/commandes.RData")
 #
 commandes |> names()
```

### fichiers DocumXML et EveXML de la table ContratEW (contrats)

```{r}
load("C:/Users/datch/Desktop/aviviaMandatDoc/data/contrats.RData")
 #
 contrats |> names()
```

### fichiers ProjetXML de la table ProjetEw (projets)

```{r}
 load("C:/Users/datch/Desktop/aviviaMandatDoc/data/projets.RData")
 #
 projets |> names()
```

## diagrammmes de sélection des entités pour l'analyse

```{mermaid}
graph TD
   

   
    Document -->|contient| Commandes
    Document -->|contient| Contrat
    Kit -->| lié à | Document
    
    Projet -->| lié à | Document 
    
    Projet -->|contient| AdrCivique
 
   
```

# Nettoyage des données

```{r}
#| include: false

load("C:/Users/datch/Desktop/aviviaMandatDoc/data/commandes.RData")
load("C:/Users/datch/Desktop/aviviaMandatDoc/data/contrats.RData")
load("C:/Users/datch/Desktop/aviviaMandatDoc/data/projets.RData")

```

```{r}
# cleaned fuctions
dropColunmSpecialChr <- function(tbl){
   tbl <- tbl |> rename_with(~ gsub("[^A-Za-z0-9]", "", .)) |>
    rename_with(
       ~ ifelse(grepl("s$", .x), sub("s$", "", .x), .x)
    ) 
}
castColunmToLower <- function(tbl){
  tbl <- tbl |> rename_with(~tolower(.))
}
cleanEmpytColumn <- function(tbl){
  df_clean <- tbl |> select_if(~!all(is.na(.)))
  df_clean
}
cleanUnimportantCols <- function(tbl){
  df_clean <- tbl |> select(!contains(c('js')))
  df_clean
}
cleanDuplicateCols <- function(tbl){
  tbl[, !duplicated(as.list(tbl))]
}
cleanDuplicateRows <- function(tbl){
  df_clean <- tbl |> distinct()
}
cleanSpecialChar <- function(x){
   if (is.character(x) || is.factor(x)) {
    x <- as.character(x) %>%
      # Supprimer tous les caractères spéciaux sauf lettres, chiffres, espaces et certains caractères utiles
      str_replace_all("[^[:alnum:] ,._-", "") %>%
      
      # Remplacer les espaces multiples par un seul espace
      str_squish() %>%
      # Convertir les chaînes vides en NA
      na_if("")
   }
  
  return(x)
}
cleanData <- function(tbls){
  tbls <- tbls |> 
    map(cleanDuplicateCols) |>
    map(dropColunmSpecialChr)|>
    map(castColunmToLower) |>
    map(cleanEmpytColumn) |>
    map(cleanUnimportantCols) 
    
}
# 
TableContratsNettoyees <- contrats[c("Contrat","Etape","Kit","Lumiere")] |> cleanData()
TableCommandesNettoyees <- commandes[c("Comm","Etape","Kit","Lumiere")] |> cleanData()
TableProjetsNettoyees <- projets[c("AdrCivique","Client","Marche","Projet")] |> cleanData()



```

# selection des variables pertinentes

## table documents (commandes & contrats )

```{r}
#| echo: false

documents <- bind_rows(TableCommandesNettoyees$Comm,TableContratsNettoyees$Contrat)

vars_selectionnees <- c(
  # Suivi de projet / gestion interne
  "projet", "code","sorte",
  # Clientèle et segmentation
  "codeclient2","typeclient", "typeproces", "roleproprietaire",
  # Logistique & délais
  "datecreation" , "nbjourvalide", "datereqexped", "delaiprevexped",
  #
  "installation" ,  "installateur",
  # Analyse produit / portefeuille
  "qteitem", "qteitemscab", "type", "assemblage", "lumiere", "gamme",
  # Performance commerciale / ventes
  "pourcesc", "totalht", "codetaxe",  "tauxtaxe", "codetaxe2", "tauxtaxe2", "total",
  # Gestion financière
  "solde", "acompte1", "acompte2"
)
# nettoyage
documents <-  documents |> 
  mutate(
    datereqexped = gsub("true", "", datereqexped),
    acompte1 = as.numeric(gsub('[%""]', "", acompte1)),
    acompte2 = as.numeric(gsub('[%""]', "", acompte2))
  )|> mutate(installation = ifelse(installation == "", NA, installation)) |>
              filter(!grepl("PSD", total, ignore.case = TRUE)) 
#
documents <-  documents |> select(all_of(vars_selectionnees))

documents |> colnames()
```

## table kits

```{r}
#| echo: false

variables_strategiques <- c(
  # Identifiants et regroupement
  "no", "nokititem", "code", "nom", "typekit", "contrat", "commande", 
  
  # Quantités et revenus
  "qte", "qtetr", "soustotalkit", "soustotal", "gtot", 
  
  # Caractéristiques produits
  "portemodeleb", "portemodeleh", "beammodele", 
  "moullumheight", "moulpiedheight", 
  "typecolor", "specie", "finishcolor", "serie", "ligne",
  "cabdesign", "cabtypecomptoir", "comptoirmod",
  
  # Prix et coûts
  "pricematcumul", "pricemocumul", "costmatcumul", "costmocumul",
  
  # Segmentation
  "kitutilisation", "estextra", "enerreur"
)

kits <- bind_rows(TableCommandesNettoyees$Kit, TableContratsNettoyees$Kit) 


kits <- kits |> select(all_of(variables_strategiques))

kits |> colnames()
```

## table projets

```{r}
#| echo: false

segmentation_clients <- c(
  # Identifiants et métadonnées  
  "code", "client", "datecreation","coderepresentant", "coderepresentant2", "nomrepresentant",  "nomrepresentant2", 
  # Segmentation commerciale  
  "libre", "enfusion", "adocument","marche","estreprise","division",
  # Données démographiques/contact  
  "nomclientfin", "prenomclient", "courrielclient", "telephoneclient",  
  "coordsfact", "coordsfacttxt", "coordsexped", "coordsexpedtxt",  
  "coordscomm", "coordscommtxt",  
  # Interaction et suivi  
  "nomcontact", "postecontact", "courrielcontact","createurnom"  
)
projets <- TableProjetsNettoyees$Projet
projets <- projets |> select(all_of(segmentation_clients))

projets |> colnames()
```

## table Adresse civiques

```{r}
#| echo: false
addresses <- TableProjetsNettoyees$AdrCivique
addresses |> colnames()
```

# Transformation des données

## conversion des variables colonnes ) dans les types appropriés pour l'analyse

### table documents

```{r}
documents <- documents |>
  mutate(
    # Conversion des dates
    datecreation = ymd(datecreation),
    datereqexped = ymd(datereqexped),
    
    # Conversion des variables numériques
    across(c(nbjourvalide, delaiprevexped, qteitem, qteitemscab, 
             totalht, tauxtaxe, tauxtaxe2, total,acompte1,acompte2, solde),
           ~ as.numeric(.)),
    
    # Conversion des pourcentages (si pourcesc est un pourcentage)
    pourcesc = as.numeric(pourcesc),
    
    # Conversion des booléens
    installation = case_when(
      tolower(installation) %in% c("true", "vrai", "1", "oui") ~ TRUE,
      tolower(installation) %in% c("false", "faux", "0", "non", "") ~ FALSE,
      TRUE ~ NA
    ),
    
    # Conversion des facteurs
    across(c(sorte, codeclient2, typeclient, typeproces,
             roleproprietaire, installateur, type, assemblage, lumiere, gamme,
             codetaxe, codetaxe2),
           ~ as.factor(.))
  )

documents |> glimpse()
```

### table kits

```{r}
library(dplyr)

kits <- kits |>
  mutate(
    # Identifiants (texte/chaine de caractères)
    no =as.factor(no),
    nokititem =as.factor(nokititem),
    nom =as.factor(nom),
   
    
    # Variables catégorielles (facteurs)
    typekit = as.factor(typekit),
    typecolor = as.factor(typecolor),
    specie = as.factor(specie),
    finishcolor = as.factor(finishcolor),
    serie = as.factor(serie),
    ligne = as.factor(ligne),
    cabdesign = as.factor(cabdesign),
    cabtypecomptoir = as.factor(cabtypecomptoir),
    comptoirmod = as.factor(comptoirmod),
    kitutilisation = as.factor(kitutilisation),
    
    # Variables logiques (TRUE/FALSE)
    estextra = as.logical(estextra),
    enerreur = as.logical(enerreur),
    
    # Variables numériques
    qte = as.numeric(qte),
    qtetr = as.numeric(qtetr),
    soustotalkit = as.numeric(soustotalkit),
    soustotal = as.numeric(soustotal),
    gtot = as.numeric(gtot),
    moullumheight = as.numeric(moullumheight),
    moulpiedheight = as.numeric(moulpiedheight),
    pricematcumul = as.numeric(pricematcumul),
    pricemocumul = as.numeric(pricemocumul),
    costmatcumul = as.numeric(costmatcumul),
    costmocumul = as.numeric(costmocumul),
    
    # Variables texte pour les modèles (peuvent être converties en facteurs si nécessaire)
    portemodeleb =as.factor(portemodeleb),
    portemodeleh =as.factor(portemodeleh),
    beammodele =as.factor(beammodele)
  )

kits |> glimpse()
```

### table projets

```{r}
library(dplyr)
library(lubridate)  # Pour la gestion des dates

projets <- projets |>
  mutate(
    # ---- Identifiants uniques ----
    client = as.factor(client),
    
    # ---- Dates ----
    datecreation = ymd_hms(datecreation),  # Convertit en format datetime
    
    # ---- Variables catégorielles ----
    marche = as.factor(marche),
    division = as.factor(division),
    libre = as.factor(libre),
    enfusion = as.factor(enfusion),
    adocument = as.factor(adocument),
    postecontact = as.factor(postecontact),
    
    # ---- Variables booléennes ----
    estreprise = as.logical(estreprise),
    
    # ---- Représentants/commerciaux ----
    coderepresentant = as.factor(coderepresentant),
    coderepresentant2 = as.factor(coderepresentant2),
    nomrepresentant = as.factor(nomrepresentant),
    nomrepresentant2 = as.factor(nomrepresentant2),
    
    # ---- Données clients ----
    nomclientfin = as.factor(nomclientfin),
    prenomclient = as.factor(prenomclient),
    nomcontact = as.factor(nomcontact),
    createurnom = as.factor(createurnom),
    
    
    # ---- Données géographiques ----
    coordsfact = as.factor(coordsfact),
    coordsfacttxt = as.factor(coordsfacttxt),
    coordsexped = as.factor(coordsexped),
    coordsexpedtxt = as.factor(coordsexpedtxt),
    coordscomm = as.factor(coordscomm),
    coordscommtxt = as.factor(coordscommtxt)
  )

projets |> glimpse()

```

### table addresses

```{r}
library(dplyr)

addresses <- addresses %>%
  mutate(
    # Identifiants uniques
    # Adresse physique
    ligne1 = as.factor(ligne1),
    ligne2 = as.factor(ligne2),
    ville = as.factor(ville),
    codepost = as.factor(codepost),
    
    # Localisation géographique
    etatprov = as.factor(etatprov),
    pay = as.factor(pay),
    region = as.factor(region),
    
    # Métadonnées
    usage = as.factor(usage),
    sorte = as.factor(sorte),
    
    # Contacts
    nom = as.factor(nom),
    contact = as.factor(contact)
  )

addresses |> glimpse()
```

# nettoyage final des donnéees

```{r}
library(dplyr)
library(stringr)

# nettoyages des données de colonnes de type facteur des caractères spéciaux etc...
cleanFactorRows <- function(df) {
  df %>%
    mutate(across(where(is.factor), ~ {
      # Convertir le facteur en caractère
      x <- as.character(.)
      
      # 1. Supprimer "true" (insensible à la casse)
      x <- str_remove_all(x, regex("true", ignore_case = TRUE))
      
      # 2. Supprimer les caractères spéciaux (conserve lettres, chiffres, espaces)
      x <- str_replace_all(x, "[^[:alnum:] ]", " ")
      
      # 3. Nettoyer les espaces multiples
      x <- str_squish(x)
      
      # 4. Convertir les chaînes vides en NA
      x <- na_if(x, "")
      
      # Recréer le facteur
      as.factor(x)
    }))
}

#
documents <- documents |> cleanFactorRows()
kits <- kits |> cleanFactorRows()
projets <- projets |> cleanFactorRows()
addresses <- addresses |> cleanFactorRows()

#

documents |> glimpse()
kits |> glimpse()
projets |> glimpse()
addresses |> glimpse()
```

# sauvegarde des données prétratées

```{r}
save(documents,file = "../data/cleaned/documents.RData")
save(kits,file = "../data/cleaned/kits.RData")
save(projets,file = "../data/cleaned/projets.RData")
save(addresses,file = "../data/cleaned/addresses.RData")
```
